# -*- coding: utf-8 -*-
"""stunting_pred.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NwaAuJlhqA522awtGHHvi4IJ6Kn95-aD

## Business Understanding

## Data Understanding
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler, LabelEncoder

import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split

# Library Evaluasi Model
from sklearn.metrics import confusion_matrix,accuracy_score, ConfusionMatrixDisplay, classification_report

df = pd.read_csv('data/data_balita.csv')
df

df.head()

df.tail()

df.sample(10)

df.describe()

df.describe(include='all')

# Menampilkan info dari tiap kolom dataset
df.info()

"""Dari kolom dataset diatas dapat diketahui bahwa :
* Umur :Merupakan umur anak dalam hitungan bulan
* Jenis Kelamin : Jenis Kelamin anak
* Tinggi badan (cm) : Tinggi badan anak dalam centimeter
* Status Gizi : Status gizi yang dikategorikan menjadi 4 status - 'severely stunting', 'stunting', 'normal', dan 'tinggi'. 'Severely stunting' menunjukkan kondisi sangat serius (<-3 SD), 'stunting' menunjukkan kondisi stunting (-3 SD sd <-2 SD), 'normal' mengindikasikan status gizi yang sehat (-2 SD sd +3 SD), dan 'tinggi' (height) menunjukkan pertumbuhan di atas rata-rata (>+3 SD).

### Mengecek nilai null
"""

df.isna().sum()

"""tidak nilai null dalam data

### Mengecek Outlier
"""

q1 = df.select_dtypes(exclude=['object']).quantile (0.25)
q3 = df.select_dtypes(exclude=['object']).quantile (0.75)
iqr = q3-q1
iqr

# Melihat batas bawah
batas_bawah = q1 - (1.5 * iqr)
batas_bawah

# Melihat batas atas
batas_atas = q3 + (1.5 * iqr)
batas_atas

# Menampung kolom dengan tipe data selain object
df_outlier = df.select_dtypes(exclude=['object'])

# Filter outlier pada dataset dengan batas bawah dan atas
outlier_filter = ((df_outlier < batas_bawah) | (df_outlier > batas_atas))
outlier_filter.sample(10)

# Menghitung Jumlah Outlier Pada Data
for col in outlier_filter.columns :
    print('Nama Kolom:',col)
    print(outlier_filter[col].value_counts())
    print('-------------------')

plt.figure(figsize=(20,2))
sns.boxplot(data=df_outlier, x='Tinggi Badan (cm)')

"""data outlier pada kolom tinggi badan sudah dihapus

### Univariate Analysis
"""

numerical_col = df.select_dtypes(exclude='object').columns.to_list()
category_col = df.select_dtypes(exclude =['int64', 'float64']).columns.to_list()

feature = category_col[0]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
df_cat = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df_cat)
count.plot(kind='bar', title=feature);

"""visualisasi data diatas menunjukkan bahwa distribusi gender sangat seimbang yaitu berada kurang lebih 60 ribu data"""

feature = category_col[1]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
df_cat = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df_cat)
count.plot(kind='pie', title=feature);

"""Dari visualisasi grafik diatas dapat dilihat bahwa lebih dari 50% data memiliki status gizi normal"""

df.hist(bins=50, figsize=(15,8))
plt.show()

"""* Data umur tampaknya memiliki distribusi yang seragam di setiap interval, kecuali pada beberapa bagian tertentu yang lebih rendah.
* Terdapat gap yang besar pada bagian tertentu data umur, mungkin terjadi karena kesalahan pencatatan atau kelompok umur tertentu tidak terwakili.
* Distribusi data tinggi badan menunjukkan bentuk yang mendekati normal atau distribusi dengan puncak yang berada di sekitar tinggi badan tertentu.
* Dari visualisasi ini, kita bisa mengamati bahwa sebagian besar individu dalam dataset memiliki tinggi badan sekitar 80-100 cm, dan jumlahnya menurun pada tinggi badan yang lebih rendah atau lebih tinggi dari itu.

### Multivariate Analysis
"""

plt.figure(figsize=(15,8))
sns.countplot(x="Status Gizi",hue='Jenis Kelamin', data=df, palette="Set2")

# Mengamati hubungan antar fitur numerik
sns.pairplot(data=df, diag_kind = 'kde')

"""dari grafik pairplot diatas dapat dilihat bahwa terdapat hubungan yang positif antara umur dan tinggi badan, dimana semakin banyak jumlah umur anak maka tinggi badan mereka juga semakin tinggi.

## Data Preparation

#### Handling Outlier
"""

# Memangkas Outlier
df = df[~((df_outlier < q1 - 1.5 * iqr) | (df_outlier > q3 + 1.5 * iqr)).any(axis=1)]

plt.figure(figsize=(20,2))
sns.boxplot(data=df, x='Tinggi Badan (cm)')

"""#### Label Encoder"""

for i in (category_col) :
    print(df[i].value_counts())
    print("==================")

encoder = LabelEncoder()
for col in category_col:
    df[col] = encoder.fit_transform(df[col])

df.head()

"""### Scalling / Standarisasi"""

scaler = StandardScaler()
df[numerical_col] = scaler.fit_transform(df[numerical_col])
df.head()

col_corr = df.corr()

plt.figure(figsize=(20, 8))
sns.heatmap(col_corr, annot=True)

# Mengambil beberapa sampel data
normal = df[df['Status Gizi'] == 0].sample(5000)
sev = df[df['Status Gizi'] == 1].sample(5000)
stun = df[df['Status Gizi'] == 2].sample(5000)
tinggi = df[df['Status Gizi'] == 3].sample(5000)

df = pd.concat([normal,sev, stun, tinggi],axis=0)
df.shape

X = df.drop('Status Gizi', axis=1)
y = df['Status Gizi']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print('Panjang data train : ', len(X_train))
print('Panjang data test : ', len(X_test))

"""## Modeling

### Random Forest
"""

from sklearn.ensemble import RandomForestClassifier
rf_model = RandomForestClassifier()
rf_model.fit(X_train, y_train)

# Mengevaluasi kinerja hasil latih model Random Forest
y_pred_rf = rf_model.predict(X_test)
cm = confusion_matrix(y_test, y_pred_rf)
print("Akurasi Random Forest : ", accuracy_score(y_test, y_pred_rf))
display_cm = ConfusionMatrixDisplay(cm)
print(classification_report(y_test, y_pred_rf))
display_cm.plot()

"""### XGBoost"""

from xgboost import XGBRFClassifier

xgb_model = XGBRFClassifier()
xgb_model.fit(X_train, y_train)

# Mengevaluasi kinerja hasil latih model XGBoost
y_pred_xgb = xgb_model.predict(X_test)
cm = confusion_matrix(y_test, y_pred_xgb)
print("Akurasi XGBoost : ", accuracy_score(y_test, y_pred_xgb))
display_cm = ConfusionMatrixDisplay(cm)
print(classification_report(y_test, y_pred_xgb))
display_cm.plot()

"""### Decision Tree"""

from sklearn.tree import DecisionTreeClassifier

dtree_model = DecisionTreeClassifier()
dtree_model.fit(X_train, y_train)

# Mengevaluasi kinerja hasil latih model Decision Tree
y_pred_dtree = dtree_model.predict(X_test)
cm = confusion_matrix(y_test, y_pred_dtree)
print("Akurasi Decision Tree : ", accuracy_score(y_test, y_pred_dtree))
display_cm = ConfusionMatrixDisplay(cm)
print(classification_report(y_test, y_pred_dtree))
display_cm.plot()

"""## Evaluation

Tahap ini merupakan tahap evaluasi terhadap ketiga model yang sudah dibuat untuk dipilih model mana yang terbaik
"""

models = pd.DataFrame(index=['train', 'test'],
                      columns=['Random Forest', 'XGBoost', 'Decision Tree'])

models.loc['train', 'Random Forest'] = accuracy_score(y_pred=rf_model.predict(X_train), y_true=y_train)
models.loc['train', 'XGBoost'] = accuracy_score(y_pred=xgb_model.predict(X_train), y_true=y_train)
models.loc['train', 'Decision Tree'] = accuracy_score(y_pred=dtree_model.predict(X_train), y_true=y_train)

models.loc['test', 'Random Forest'] = accuracy_score(y_test, y_pred_rf)
models.loc['test', 'XGBoost'] = accuracy_score(y_test, y_pred_xgb)
models.loc['test', 'Decision Tree'] = accuracy_score(y_test, y_pred_dtree)


models

models.transpose()

accuracy_data = models.loc['test'].sort_values(ascending=False).reset_index()
accuracy_data.columns = ['Model', 'Accuracy']

# Membuat plot
plt.figure(figsize=(8, 4))
sns.barplot(x='Accuracy', y='Model', data=accuracy_data, palette='viridis')
plt.title('Akurasi model pada data uji')
plt.xlabel('Accuracy')
plt.ylabel('Model')
plt.xlim(0, 1)
plt.show()

"""Dari ketiga model yang sudah dilakukan testing, melalui visualisasi data diatas dapat dilihat bahwa model Random Forest memiliki nilai akurasi tertinggi yang mencapai akurasi 98.7%. Sehingga model inilah yang akan dipilih untuk dilakukan development selanjutnya."""

